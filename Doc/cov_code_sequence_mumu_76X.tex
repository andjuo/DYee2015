\documentclass[a4paper]{article}

\pdfoutput=1
%\usepackage{jheppub} 

\usepackage{lineno}
\usepackage[pdftex]{graphicx}
\usepackage{xstring} % StrSubstitute
\usepackage{ulem} % sout
%\graphicspath{{dir-figs/}}

\usepackage{stmaryrd,xcolor}
\newcommand{\textred}[1]{{\color{red!70!black}#1}}
\newcommand{\textgreen}[1]{{\color{green!50!black}#1}}
\newcommand{\textblue}[1]{{\color{blue!90!black}#1}}
\newcommand{\lumi}[1]{{\cal L}_{\mathrm{#1}}}

\def\myund#1{%
  \saveexpandmode\expandarg
  \IfSubStr{#1}{_}{%
   \StrSubstitute{#1}{_}{\_}}{#1}%
  \restoreexpandmode
}


\title{Calculation of the covariance matrix for the Drell-Yan measurement in the muon channel: Code sequence}
\author{A.~Juodagalvis\\[2mm]
\small
Vilnius University, Institute of Theoretical Physics and Astronomy, \\
\small Saul{\. e}tekio al.\ 3, Vilnius 10222, Lithuania}

\begin{document}
\linenumbers

%\abstract{Information about the needed data structures.}
\maketitle

\section{Dimuon covariance calculation}

Explanation of the code sequence used to derive the covariance
matrices of the 1D measurement in the muon channel. Explanation is
based on the provided data with the tag ``76X''.

The 1D Drell-Yan cross section measurement provides the cross section
values in bins of mass

\begin{equation}
\frac{d\sigma}{dM}\ =\ {\cal F}^{-1}_\mathrm{FSR}
\left\{
\frac{
  {\cal F}^{-1}_\mathrm{resol}\{ N_\mathrm{obs.yield} - N_\mathrm{bkg.yield} \}
}{
  A \varepsilon \rho \lumi{int}
}
\right\},
\end{equation}
where ${\cal F}^{-1}_\mathrm{X}$ denotes the unfolding correction for
the detector ($X=\mathrm{resol}$) and FSR ($X=\mathrm{FSR}$) effects,
$N_\mathrm{obs.yield}$ is the measured event yield,
$N_\mathrm{bkg.yield}$ is the estimated background yield, $A$ is the
event acceptance, $\varepsilon$ is the event efficiency, $\rho$ is
the efficiency correction factor, and $\lumi{int}$ is the total
integrated luminosity.

Due to the differences in the HLT menus v.4.2 and v.4.3, the
measurement in the muon channel is subdivided into two run periods.
The background yield is estimated from all data, thus the cross
section measurement is calculated as
\begin{equation}
\frac{d\sigma}{dM} =
\frac{1}{\lumi{int.tot}}
{\cal F}_{\mathrm{FSR}^{-1}}
\left\{
  \sum\limits_{\mathrm{HLTvX: X=4.2,4.3}}
  \frac{%
    {\cal F}_{\mathrm{resol}}^{-1}
    \left\{
    N_\mathrm{obs.yield,HLTvX} -
    \frac{\lumi{int,HLTvX}}{\lumi{int,tot}} N_\mathrm{bkg.yield}
    \right\}
  }
  {A\varepsilon \rho_{HLTvX}}
\right\},
\end{equation}
where $\lumi{int,HLTv4.2}=848.104$~pb${}^{-1}$ and
$\lumi{int,HLTv4.3}=1917.125$~pb${}^{-1}$.

\medskip

All relevant macros are placed in subdirectory {\sf Covariance}. The
header file \myund{crossSection.h}\ contains main class definitions
used when deriving the covariance matrix: \myund{CrossSection_t}\ and
\myund{MuonCrossSection_t}. The header file \myund{inputs.h}\
contains many auxiliary functions. The header file
\myund{DYmm13TeV.h}\ defines class \myund{DYmm13TeV_t}\ that has a
description of the Drell-Yan event file in the muon channel containing
data in the ROOT format.

\textbf{First, we need to convert the input files.} The macro is called
\myund{createCSInput_DYmm13TeV.C}. One needs to specify the source
path variable \myund{srcPath}\ to point to relevant location.
The variables (inpVer and inpVerTag, defined in
crossSection.h) have to be updated as well. The macro should be run
with pre-compilation:
\begin{verbatim}
.x createCSInput_DYmm13TeV.C+(doSave)
\end{verbatim}
The variable doSave is 1 for saving the resulting ROOT file. The
default value is 0 (no save).

The first input file is
\myund{Input1/ROOTFile_Histograms_Data.root}. The histograms are
\myund{h_data_HLTv4pX}\ and \myund{h_yield_HLTv4pX}, where X=2 and
3. They are loaded under names \myund{h1Yield_4X}\ and
\myund{h1Signal_4X}. These histograms correspond to
$N_\mathrm{obs.yield,HLTvX}$ and $(N_\mathrm{obs.yield,HLTvX} -
      {\lumi{int,HLTvX}}/{\lumi{int,tot}} N_\mathrm{bkg.yield})$.
% 
Note that no events were registered in the mass range 1500-3000~GeV
during the run period HLTv4.2.

The second input file
\myund{Input2/ROOTFile_Histograms_Bkg.root}\ contains several
backgrounds. The expected ones are given in histograms \myund{h_XX},
where 'XX' stands for ZZ, WZ, WW, ttbar (TTbar), DYtautau, tW (TW),
WJets, QCD. Those backgrounds are listed as the enumerated type
\myund{TBkg_t}\ in \myund{crossSection.h}. Their variable names are
\myund{_bkgXX}, where 'XX' stands for the background name (note, that
ttbar and tW are named \myund{_bkgTTbar}\ and \myund{_bkgTW}).

If the variable \myund{checkBackgrounds}\ is set to 1, the code will
try to verify whether the backgrounds are reasonable. The code takes
the yield histogram and subtracts the signal histogram. This should
yield the background distribution (after corrections for the run
luminosities).
Inputs v1 had
improperly normalized ZZ, WZ, and WW backgrounds. This trouble is
fixed in version 76X. (The following problem was fixed on June 3, 2016:
\sout{However, here is a non-trivial mismatch between
$(h_\mathrm{yield}-h_\mathrm{signal})/sum_{\mathrm{bkg}}(h_\mathrm{bkg})$. It
varied between $-3\%$ in the first mass bin up to $+5\%$ in the mass
bin 42, 1000-1500~GeV. The difference is the same in both versions
HLTv4.X.})

The third input file is
\myund{Input6/ROOTFile_Input6_CrossCheck.root}. It contains several
objects of type \myund{TGraphAsymmErrors}: acceptance $A$
(\myund{g_Acc}), efficiency $\varepsilon$ (\myund{g_Eff}),
$A\times\varepsilon$ (\myund{g_AccEff}), efficiency correction scale
factors $\rho$ (\myund{g_EffSF_HLTv4pX}, where X=2 and 3). Two objects
of type \myund{RooUnfoldResponse}\ give the corrections of the
detector resolution and the final-state radiation
(\myund{UnfoldRes_DetectorResol}\ and \myund{UnfoldRes_FSR},
respectively). The unfolded data is stored in the histogram
\myund{h_DiffXsec_Data}. All graphs are converted to histograms with a
symmetrized uncertainty.

The loaded values are assigned to an instance of
\myund{MuonCrossSection_t}\ and saved to a file
\myund{``cs_DYmm_13TeV''+inpVerTag}. Actually, three files will be
produced: \myund{cs_DYmm_13TeV_76X_csA.root},
\myund{cs_DYmm_13TeV_76X_csB.root}, and\linebreak
\myund{cs_DYmm_13TeV_76X_cs.root}. (Here the tag \myund{'_76X'}\ was
used.)

Note from June 3, 2016. The current version of 76X set has fixed the
background mismatch. However, the difference between the calculated
cross section distribution and the distribution provided by Kyeongpil
amounts to $2.439\%$. Since this difference is almost flat, it may be
due to some unaccounted factor that has changed. The variation takes
place only in the mass bins 830-1000~GeV (the relative difference is
$2.567\%$ and 1000-1500~GeV ($1.135\%$).

\textbf{Secondly, the randomized event-effciency scale factors should
  be prepared.}  The code \myund{process_DYmm_RECO.C}\ reads the
``compressed'' n-tuple and produces detector resolution and the
efficiency scale factor corrections. It also saves 1D distributions of
the pre-unfolded and unfolded yields, and copies the single-muon
efficiencies from the provided input5. It also produces distributions
needed to calculate the event-efficiency scale factor in an optimized
way. The output is saved to a file
\myund{dymm_test_RECO_$<$InpVersion$>$.root}.

The randomized ensemble of the event-efficiency scale factors is
produced by the code \myund{calcRhoRndVec.C}. It reads the file
\myund{dymm_test_RECO_$<$InpVersion$>$.root}. It also compares the
scale factors to the provided values. The random ensemble is saved to
a file
\myund{dir-Rho-$<$InpVersion$>$/dymm_rhoRndVec_$<$InpVersion$>$_$<$NSamples$>$.root}.

\textbf{Thirdly, the covariances are being derived.} The macro is
called \myund{studyDYmmCS.C}. This macro has several input parameters:
the varied variable \myund{TVaried_t}\ (the enum type is defined in
crossSection.h); the number of toy distributions nSample; and a flag
whether the resulting ROOT file should be saved, doSave. Before first
use, the macro has to be updated to indicate the correct version of
the input files by specifying the right values of the variables inpVer
and inpVerTag. Those are equivalent to the ones defined in
\myund{createCSInput_DYmm13TeV.C}.

Currently the macro \myund{studyDYmmCS.C}\ can vary \myund{_varYield},
\myund{_varBkg}, \myund{_varBkgXS}, \myund{_varDetRes}\ (statistical
uncertainty of the detector resolution response matrix),
\myund{_varFSRRes}\ (statistical uncertainty of the FSR response
matrix), \myund{_varEff}, \myund{_varAcc}, and \myund{_varEffAcc}.
The unimplemented variables are: \myund{_varSig}, \myund{_varRho}.
(Note: \myund{_varRhoFile}\ is implemented to use the ensemble
produced by the code \myund{calcRhoRndVec.C}.)

Note June 8: It seems that the uncertainties from \myund{_varEff} and
\myund{_varAcc} are smaller than the ones provided for
\myund{_varEffAcc}. That is, the combined uncertainty of
$\varepsilon\times A$ is smaller than provided by KL.

The code \myund{calcRhoRndVec.C}\ compares the calculated event
efficiency scale factor to the provided event efficiency scale factor.

\subsection{Verification}

The code \myund{createCSInput_DYmm13TeV.C}\ verifies several things.
1)~The provided backgrounds by comparing the sum of
the provided background counts to the difference of the provided
observed yield and the signal yield (observed yield with the
background subtracted). 2)~The uncertainties of the combined quantities
$\epsilon_\mathrm{MC}\times A$. It compares whether those
uncertainties are equal or smaller than the uncertainties of the
combination. Since
$\epsilon_\mathrm{MC}=N_\mathrm{sel,inAcc,postFSR}/N_\mathrm{inAcc,postFSR}$
and $A=N_\mathrm{inAcc,postFSR}/N_\mathrm{postFSR}$, the combination
$\epsilon_\mathrm{MC}\times
A=N_\mathrm{sel,inAcc,postFSR}/N_\mathrm{postFSR}$ can have a smaller
uncertainty. This, however, is not exploited.
3)~The provided cross section and the inputs by calculating the final
cross section from the provided inputs and comparing it to the
provided final cross section.

The event-efficiency scale factors are tested by two codes.  The code
\myund{calcRhoRndVec.C}\ tests the output of the code
\myund{processDYmm_RECO.C}\ by comparing the produced scale factor to
the provided values.  The code \myund{processDYmm_avgRho2.C}\ verifies
that the event-efficiency scale factors derived by using the event
space correspond to the provided scale factor distributions.

The code \myund{processDYmm.C}\ reads the ``compressed'' n-tuple and
produces several distributions that lead to the efficiency, acceptance
and the FSR corrections.
 The output is saved to a file
\myund{dymm_test_$<$InpVersion$>$.root}.
This file is later used by a complicated code
\myund{study_FSRResp.C}\ that compares several items.

The code \myund{study_FSRResp.C}\ reads the main result file
\myund{cs_DYmm_13TeV_$<$ShortInpVersion$>$_cs.root}\ (fnameMain) to
get post-FSR and pre-FSR distributions h1PostFSR and h1PreFSR
(variables nameh1preUnfData and nameh1unfData). Those distributions
are obtained from the provided measured data by applying the provided
corrections.  The FSR-correction may be read from several sources
(including the main result file fnameMain).  The file and the object
names are given by variables fnameResp and nameResp.  For 76X input
version, the object \myund{rooUnf_fsrResp} is taken from a file
\myund{dymm_test_$<$InpVersion$>$.root}\ that is produced by the code
\myund{processDYmm.C}. The simulated distributions are read-in from a
file defined by fnameMC and given by the variables nameh1measMC and
nameh1trueMC (\myund{h1_postFSR_Mweighted}\ and
\myund{h1_preFsr_Mweighted}). To be able to test the early result in
the electron channel by using the migration matrix, a variable was
introduced nameh2migrationMatrix. The code can also read-in the
covariance from the randomized response. The variable is covFName and
nameh2cov with the values \myund{cov_mumu_varFSRRes_10000.root}\ and
h2Cov.

% ----------------------------------
\section{Dielectron covariance calculation}

The code sequence for the dielectrons:
(1)~\myund{createCSInput_DYee13TeV.C},
(2)~\myund{processDYee_dressed.C}, (3)~\myund{calcRhoRndVec_ee.C},
(4)~\myund{studyDYeeCS.C}.

(Added Jan 19, 2017)\\\noindent The code
\myund{calcRhoRndVec_ee_syst.C}\ is used to produce several kinds of
event efficiency systematic uncertainties by use of ``alternative
tables'' of the efficiencies derived changing the selection or the fit
(e.g.\ sigPdf, bkgPdf, tagDef - for data, NLOvsLO - for MC). The use
is \myund{calcRhoRndVec_ee_syst.C+(1,0,1,1111)}.  This produces the
files needed for systematic evaluations by code
\myund{studyDYeeCS.C+(_varRhoSyst,0,0)}.

% ----------------------------------
\section{Calculation of the statistical uncertainty covariance matrix}

Because of the fluctuations in the correlation matrix from the
measured yield statistical uncertainty, a sequence of codes was
developed to study the stability.

For the muon channel:\\
Step 1: \muynd{studyDYmmCS.C+(_varYield,Nsample,2)}\\
Step 2: \myund{studyDYmmCScovYield.C+(Nsample,iMethod,1,plotPeriodA)}\\
Step 3: \myund{studyDYmmCScovYieldMethods.C+(Nsample)}

For the electron channel:\\
Step 1: \myund{studyDYeeCS.C+(_varYield,Nsample,2)}\\
Step 2:
\myund{studyDYeeCScovYield.C+(Nsample,iMethod,1,plotMassDistr)}\\
Step 3: \myund{studyDYeeCScovYieldMethods.C+(Nsample)}

The value of Nsample determines how large the Gauss-randomized
ensemble should be created. The number 2 in the code studyDYxxCS.C
argument list indicates that saving of a slimmed version is requested
(the ROOT file will contain a tag 'slim'). If changed to 0, saving is
not done. The value of 1 saves ``full version''.
The number 1 in the code studyDYxxCScovYield.C argument list indicates
that the result file should be saved. The value of iMethod should be
1, 2, or 3. The code studyDYeeCScovYield.C also has a method 4. An
extra tag for the output file can be provided for this macro.

The macro studyDYxxCS creates the randomized ensemble and the
covariance matrix of the final uncertainties that could be used, if it
is good. The macro studyDYxxCScovYield creates the covariance matrix
from the ensemble by applying the specified method.
The macro studyDYxxCScovYieldMethods.C plots the
uncertainty values from the covariance matrices.

\end{document}

